<section>
    <h1 class="noupper">Warum Git?</h1>
    <ul>
        <li>April 2005</li>
        <li>Linus Torvalds</li>
    </ul>
    <aside class="notes">
        Git hat eine rasante Erfolgsgeschichte hinter sich. Im April 2005 begann
        Linus Torvalds, Git zu implementieren, weil er keinen Gefallen an den
        damals verfügbaren Open-Source-Versionsverwaltungen fand. Heute,
        im Herbst 2016, liefert Google Millionen von Suchtreffern, wenn man
        nach »git version control« sucht. Für neue Open-Source-Projekte ist es
        zum Standard geworden, und viele große Open-Source-Projekte sind zu
        Git migriert.
    </aside>
</section>
<section>
    <h1 class="noupper">Warum Git?</h1>
    <ul>
        <li>Arbeiten mit Branches</li>
        <li>Flexibilität in den Workflows</li>
        <li>Contribution</li>
        <li>Nachvollziehbare Herkunft von Sourcecode</li>
        <li>Performance</li>
        <li>Robust gegen Fehler und Angriffe</li>
        <li>Offline- und Multisite-Entwicklung</li>
        <li>Administrierbarkeit</li>
        <li>Starke Open-Source-Community</li>
        <li>Erweiterbarkeit</li>
    </ul>
    <aside class="notes">
        Arbeiten mit Branches: Wenn viele Entwickler gemeinsam an einer
        Software arbeiten, entstehen parallele Entwicklungsstränge, die immer
        wieder auseinanderlaufen und zusammengeführt werden müssen.
        Genau dafür ist Git entwickelt worden. Es bietet daher umfassende
        Unterstützung zum Branchen, Mergen, Rebasen und Cherry-
        Picken.
        Flexibilität in den Workflows: Manche sagen, dass Git im Grunde gar
        keine Versionsverwaltung sei, sondern ein Baukasten, aus dem sich
        jeder seine eigene Versionsverwaltung zusammensetzen kann. Git
        ist außergewöhnlich flexibel. Ein einzelner Entwickler kann es für
        sich allein nutzen, agile Teams finden leichtgewichtige Arbeitsweisen
        damit, aber auch große internationale Projekte mit zahlreichen
        Entwicklern an mehreren Standorten können passende Workflows
        entwickeln.
        Contribution: Die meisten Open-Source-Projekte existieren durch freiwillige
        Beiträge von Entwicklern. Es ist wichtig, das Beitragen so
        einfach wie nur möglich zu machen. Bei zentralen Versionsverwaltungen
        wird dies oft erschwert, weil man nicht jedem schreibenden
        Zugriff auf das Repository geben möchte. Jeder kann ein Git-
        Repository klonen, damit vollwertig arbeiten und dann später die
        Änderungen weitergeben (»Mit Forks entwickeln« (Seite 163)).
        Nachvollziehbare Herkunft von Sourcecode: Die Entwickler von Git
        haben es als Content Tracker bezeichnet. Damit meinen sie ein
        Werkzeug, das die Herkunft von Inhalten, insbesondere Source
        code, aufzeigen kann. Git kann dies selbst dann, wenn Code zusammengeführt
        wurde (Merge) oder Dateien verschoben und umbenannt
        wurden. Sogar kopierte Codeabschnitte können erkannt
        und zugeordnet werden.
        Performance: Auch bei Projekten mit vielen Dateien und langen Historien
        bleibt Git schnell. In weniger als einer halben Minute wechselt
        es zum Beispiel von der aktuellen Version auf eine sechs Jahre
        ältere Version der Linux-Kernel-Sourcen – auf einem kleinen
        MacBook Air. Das kann sich sehen lassen, wenn man bedenkt,
        dass über 200.000 Commits und 40.000 veränderte Dateien dazwischenliegen.
        Robust gegen Fehler und Angriffe: Da die Historie auf viele dezentrale
        Repositorys verteilt wird, ist ein schwerwiegender Datenverlust
        unwahrscheinlich. Eine genial simple Datenstruktur im Repository
        sorgt dafür, dass die Daten auch in ferner Zukunft interpretierbar
        bleiben. Der durchgängige Einsatz kryptografischer Prüfsummen
        erschwert es Angreifern, Repositorys unbemerkt zu korrumpieren.
        Offline- und Multisite-Entwicklung: Die dezentrale Architektur macht
        es leicht, offline zu entwickeln, etwa unterwegs mit dem Laptop.
        Bei der Entwicklung an mehreren Standorten ist weder ein zentraler
        Server noch eine dauerhafte Netzwerkverbindung erforderlich.
        Administrierbarkeit: Git ist einfach zu betreiben und zu administrieren.
        Alle Daten und Konfigurationen werden in einfachen Dateien
        gespeichert. Für Backups oder Umzüge genügen die Standardtools
        des Betriebssystems. Es muss kein Git-spezifischer Dienst eingerichtet
        werden. Alle Operationen werden durch Kommandozeilenbefehle
        bereitgestellt. Repositorys werden meist über SSH oder HTTP
        zugänglich gemacht, sodass man die Authentifizierung und Autorisierung
        des Betriebssystems bzw. Webservers nutzen kann. Zahlreiche
        mächtige Befehle erlauben es, das Repository zu manipulieren.
        Die dezentrale Natur von Git macht es leicht, Änderungen zuerst
        an einem Klon zu erproben, bevor man sie öffentlich macht.
        Starke Open-Source-Community: Neben der detaillierten offiziellen
        Dokumentation unterstützen zahlreiche Anleitungen, Foren, Wikis
        etc. den Anwender. Es existiert ein Ökosystem aus Tools, Hosting-
        Plattformen, Publikationen, Dienstleistern und Plug-ins für Entwicklungsumgebungen,
        und es wächst stark.
        Erweiterbarkeit: Git bietet neben komfortablen Befehlen für den Anwender
        auch elementare Befehle, die einen direkteren Zugang zum
        Repository erlauben. Dies macht Git sehr flexibel und ermöglicht
        individuelle Anwendungen, die über das hinausgehen, was Git von
        Haus aus bietet.
    </aside>
</section>
<section>
    <h1 class="noupper">Zentrale Versionsverwaltung</h1>
    <img src="{{ site.baseurl }}/images/zentraleversionierung.jpg" height="300">
    <aside class="notes">
        zeigt die typische Aufteilung einer zentralen Versionsverwaltung,
        z. B. von CVS oder Subversion. Jeder Entwickler hat auf
        seinem Rechner ein Arbeitsverzeichnis (Workspace) mit allen Projektdateien.
        Diese bearbeitet er und schickt die Änderungen regelmäßig per
        Commit an den zentralen Server. Per Update holt er die Änderungen der anderen Entwickler ab. Der zentrale Server speichert die aktuellen
        und historischen Versionen der Dateien (Repository). Parallele Entwicklungsstränge
        (Branches) und benannte Versionen (Tags) werden
        auch zentral verwaltet.
    </aside>
</section>
<section>
    <h1 class="noupper">Dezentrale Versionsverwaltung</h1>
    <img src="{{ site.baseurl }}/images/Dezentrale.jpg" height="300">
    <aside class="notes">
        zeigt die typische Aufteilung einer zentralen Versionsverwaltung,
        z. B. von CVS oder Subversion. Jeder Entwickler hat auf
        seinem Rechner ein Arbeitsverzeichnis (Workspace) mit allen Projektdateien.
        Diese bearbeitet er und schickt die Änderungen regelmäßig per
        Commit an den zentralen Server. Per Update holt er die Änderungen der anderen Entwickler ab. Der zentrale Server speichert die aktuellen
        und historischen Versionen der Dateien (Repository). Parallele Entwicklungsstränge
        (Branches) und benannte Versionen (Tags) werden
        auch zentral verwaltet.
    </aside>
</section>
<section>
    <h1 class="noupper">Repository Arten</h1>
    <ul>
        <li>Blessed</li>
        <li>Shared</li>
        <li>Workflow</li>
        <li>Fork</li>
    </ul>
    <aside class="notes">
        Blessed Repository: Aus Ein Projekt aufsetzen diesem Repository werden die »offiziellen« Releases erstellt.

        Shared Repository: Dieses Repository dient dem Austausch zwischen den Entwicklern im Team. In kleinen Projekten kann hierzu auch das Blessed Repository genutzt werden. Bei einer Multisite-Entwicklung kann es auch mehrere geben.

        Workflow Repository: Ein solches Repository wird nur mit Änderungen befüllt, die einen bestimmten Status im Workflow erreicht haben, z. B. nach erfolgreichem Review.

        Fork Repository: Dieses Repository dient der Entkopplung von der Entwicklungshauptlinie (zum Beispiel für große Umbauten, die nicht in den normalen Release-Zyklus passen) oder für experimentelle
        Entwicklungen, die vielleicht nie in den Hauptstrang einfließen
        sollen.
    </aside>
</section>
<section>
    <h1 class="noupper">Vorteile</h1>
    <ul>
        <li>Hohe Performance</li>
        <li>Effiziente Arbeitsweisen</li>
        <li>Offline-Fähigkeit</li>
        <li>Flexibilität der Entwicklungsprozesse</li>
        <li>Backup</li>
        <li>Wartbarkeit</li>
    </ul>
    <aside class="notes">
        Hohe Performance: Fast alle Operationen werden ohne Netzwerkzugriff
        lokal durchgeführt.
        Effiziente Arbeitsweisen: Entwickler können lokale Branches benutzen,
        um schnell zwischen verschiedenen Aufgaben zu wechseln.
        Offline-Fähigkeit: Entwickler können ohne Serververbindung Commits
        durchführen, Branches anlegen, Versionen taggen etc. und diese
        erst später übertragen.
        Flexibilität der Entwicklungsprozesse: In Teams und Unternehmen
        können spezielle Repositorys angelegt werden, um mit anderen Abteilungen,
        z. B. den Testern, zu kommunizieren. Änderungen werden
        einfach durch ein Push in dieses Repository freigegeben.
        Backup: Jeder Entwickler hat eine Kopie des Repositorys mit einer
        vollständigen Historie. Somit ist die Wahrscheinlichkeit minimal,
        durch einen Serverausfall Daten zu verlieren.
        Wartbarkeit: Knifflige Umstrukturierungen kann man zunächst auf einer
        Kopie des Repositorys erproben, bevor man sie in das Original-
        Repository überträgt.
    </aside>
</section>
<section>
    <h1 class="noupper">Das Repository</h1>
    <h2 class="noupper">die Grundlage dezentralen Arbeitens</h2>
    <p>Das Repository ist im Kern ein effizienter Datenspeicher. Im Wesentlichen enthält es:</p>
    <ul>
        <li>Inhalte von Dateien (Blobs)</li>
        <li>Verzeichnisse (Trees)</li>
        <li>Versionen (Commits)</li>
    </ul>
</section>
<section>
    <h1 class="noupper">Das Repository</h1>
    <img src="{{ site.baseurl }}/images/repository.jpg" height="300">
</section>
<section>
    <h1 class="noupper">hexadezimaler Hashwert</h1>
    <pre class=""><code class="hljs bash" data-trim data-fragment>
           1632acb65b01c6b621d6e1105205773931bb1a41.
    </code></pre>
    <aside class="notes">
        Diese Hashwerte dienen als Referenz
        zwischen den Objekten und als Schlüssel, um die Daten später
        wiederzufinden
    </aside>
</section>
<section>
    <h1 class="noupper">Vorteile Hashwert</h1>
    <ul>
        <li>Hohe Performance</li>
        <li>Redundanzfreie Speicherung</li>
        <li>Dezentrale Versionsnummern</li>
        <li>Effizienter Abgleich zwischen Repositorys</li>
        <li>Integrität der Daten</li>
        <li>Automatische Erkennung von Umbenennungen</li>
    </ul>
</section>
<section>
    <h1 class="noupper">Branching und Merging</h1>
    <ul style="list-style: none">
        <li>Verzweigen (Branching)</li>
        <li>Branches entstehen durch paralleles Arbeiten.</li>
        <li>Zusammenzuführen (Merging)</li>
    </ul>
</section>
<section>
    <h1 class="noupper">ungeplante Verzweigung</h1>
    <img src="{{ site.baseurl }}/images/ungeplanteVerzweigung.jpg" height="300">
</section>
<section>
    <h1 class="noupper">Explizite Branches</h1>
    <img src="{{ site.baseurl }}/images/Explizite.jpg" height="300">
</section>
<section>
    <h1 class="noupper">Zusammenfassung</h1>
</section>
<section>
    <h1 class="noupper">Git installieren</h1>
    <a href="http://git-scm.com/download">http://git-scm.com/download</a>
</section>
<section>
    <h1 class="noupper">Windows-User</h1>
    <p>Git-Bash</p>
    <pre class=""><code class="hljs bash" data-trim data-fragment>
> git com< TAB>
> git commit

> git c< TAB>< TAB>
checkout    cherry  cherry-pick     citool
clean       clone   commit          config

> git commit --a< TAB>< TAB>
--all   --amend     --author=</code></pre>
</section>
<section>
    <h1 class="noupper">Git einrichten</h1>
    <pre class=""><code class="hljs bash" data-trim data-fragment>
> git config --global user.name hmustermann
> git config --global user.email "hans@mustermann.de"
    </code></pre>
</section>
<section>
    <h1 class="noupper">Lieblingstexteditor</h1>
    <pre class=""><code class="hljs bash" data-trim data-fragment>
> git config --global core.editor vim           # VI improved
> git config --global core.editor "atom --wait" # Atom editor
> git config --global core.editor notepad       # Windows notepad
    </code></pre>
</section>
